/*
 * Copyright 1991, 1992, 1993, 1994, Silicon Graphics, Inc.
 * All Rights Reserved.
 *
 * This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
 * the contents of this file may not be disclosed to third parties, copied or
 * duplicated in any form, in whole or in part, without the prior written
 * permission of Silicon Graphics, Inc.
 *
 * RESTRICTED RIGHTS LEGEND:
 * Use, duplication or disclosure by the Government is subject to restrictions
 * as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
 * and Computer Software clause at DFARS 252.227-7013, and/or in similar or
 * successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
 * rights reserved under the Copyright Laws of the United States.
 */
/*
 *	event.h
 * External interface and defines to input-queue event handling
 * routines.
 * Written by Wade Olsen for Silicon Graphics, Inc.
 */

#ifdef __cplusplus
extern "C" {
#endif

/*
 *	The event handler understands two kinds of things; events and
 * updates.  Events are reactions to things occuring in the input
 * queue.  Updates are functions that should be called whenever there
 * is nothing waiting in the input queue, and may be active or
 * inactive.  If there are no active updates and nothing in the input
 * queue, then event() will block, using up no CPU time.
 *
 * add_event is used to look for events.  The first three arguments
 * are used to identify which event to look for.  The first argument
 * is the window (gid) the event must happen in; if this value is ANY
 * then any window will do.  The second argument is the device to look
 * for (e.g.  RIGHTMOUSE or REDRAW or KEYBD, etc).  Again, if it is
 * ANY then any device will match.  The third argument is the value
 * the device must generate (e.g.  DOWN or UP); ANY means all values
 * match.  The last two arguments are what should be done when an
 * event is generated.  The fourth argument is a function to be
 * called, and the fifth is an argument that should be supplied to the
 * function.  In addition, the value generated by the device will also
 * be passed to the function when it is called.
 *
 * For example,
 *	add_event(winget(), RIGHTMOUSE, DOWN, dopup, my_menus);
 *	qdevice(RIGHTMOUSE);
 * will make a pop-up menu appear when the right mousebutton goes
 * down.  Note that you must do the qdevice() call yourself.
 */
void add_event(int, int, int, void (*fn)(), void *);

/*
 * An update is like an event, only simpler.  The first argument is a
 * pointer to an integer flag specifying whether or not this update
 * function is active.  The second is a function to be called when it
 * is active, and the last is an argument to be supplied to the
 * function.
 */
void add_update(int *, void (*fn)(), void *);

/*
 * Finally, when all updates and events have been added, repeatedly
 * call event() to handle them -- something like
 * 
 *	while (quitflag == FALSE) event();
 * 
 * You should have previously added an event that sets quitflag to
 * TRUE, of course.
 */
void event(void) ;

/*
 *	event_noblock is similar to event but if there are no events or update
 * to handle, it does not block.
 */
void event_noblock();


/*
 *	These are some useful defines for the possible values buttons
 * can generate.
 */
#define ANY	-1
#define UP	0
#define DOWN	1

/*
 *	And a few external variables you might find useful
 */
extern int context, state, device;


/*
 *	Allows you to delete event and update handlers.
 */
extern void delete_events(
		int context, int device, int value, void *func);

extern void delete_updates(int * flag, void * func);

/*
 *	Other useful event handlers
 * 
 * void setInt(void * i);		    sets integer i to 1
 * void resetInt(void * i);		    sets integer i to 0
 * void setIntToVal(void * i, int v);       sets integer i to the device
 *					    value returned from qread
 */
extern void setInt();
extern void resetInt();
extern void setIntToVal();

#ifdef __cplusplus
}
#endif
